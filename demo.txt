
 particular, there is one single platform.h file which determines platform-specific settings via #if ...
C++ Namespace

ICU C++ APIs are normally defined in a versioned namespace, for example "icu_50". There is a stable "icu" alias which should be used instead. (Entry point versioning is only to allow for multiple ICU versions linked into one program. It is optional and should be off for system libraries.)

By default, and only for backward compatibility, the ICU headers contain a line using namespace icu_50; which makes all ICU APIs visible in/with the global namespace (and potentially collide with non-ICU APIs there). One of the Recommended Build Options is to turn this off.

To write forward declarations, use

U_NAMESPACE_BEGIN
class UnicodeSet;
class UnicodeString;
U_NAMESPACE_END
To qualify an ICU class name, use the "icu" alias:

static myFunction(const icu::UnicodeString &s) {...}
Frequently used ICU classes can be made easier to use in .cpp files with

using icu::UnicodeSet;
using icu::UnicodeString;
Other Notes

Helper Install Utilities

ICU installs $(prefix)/share/icu/$(VERSION)/install-sh and $(prefix)/share/icu/$(VERSION)/mkinstalldirs which may be used by ICU tools and samples. Their paths are given in the installed Makefile.inc  ( see above).
Data Packaging Settings

The pkgdata  tool (see Packaging ICU4C ) makes use of the installed file $(prefix)/lib/icu/pkgdata.inc to set parameters for data packaging operations that require use of platform compilers and linkers ( in static or dll mode).  pkgdata uses the icu-config script in order to locate pkgdata.inc. If you are not building ICU using the supplied tools, you may need to modify this file directly to allow static and dll modes to function.

Building and Running Trivial C/C++ Programs with icurun

For building and running trivial (one-compilation-unit) programs with an installed ICU4C, the shell script icurun may be used. For detailed help, see the top of that script.
As an example, if ICU is installed to the prefix /opt/local  and the current directory contains two sample programs "test1.cpp" and "test2.c", they may be compiled and run with any of the following commands.  The "-i" option specifies either the installed icu-config script,  or the directory containing that script, or the path to a 'bin' directory.
icurun -i /opt/local                 test1.cpp
icurun -i /opt/local/bin             test2.c
icurun -i /opt/local/bin/icu-config  test1.cpp
If "icu-config" is on the PATH, the -i option may be omitted:
icurun  test1.cpp
Any additional arguments will be passed to the program.
icurun  test1.cpp  args...
This feature is a work in progress, until ICU 4.8 ships please give feedback at Ticket #8481
Unicode Basics
Contents
1 Introduction to Unicode
2 Traditional Character Sets and Unicode
3 Glyphs versus Characters
4 Overview of Unicode
5 Character Encoding Forms and Schemes for Unicode
6 Overview of UTF-16
7 Overview of UTF-8
8 Overview of UTF-32
9 Overview of SCSU
10 Other Unicode Encodings
11 Programming using UTFs
12 Serialized Formats
13 The Unicode Standard Is An Industry Standard
Introduction to Unicode

Unicode is a standard that precisely defines a character set as well as a small number of encodings for it. It enables you to handle text in any language efficiently. It allows a single application executable to work for a global audience. ICU, like Java™, Microsoft® Windows NT™, Windows™ 2000 and other modern systems, provides Internationalization solutions based on Unicode.

This chapter is intended as an introduction to codepages in general and Unicode in particular. For further information, see:

The Web site of the Unicode consortium

What is Unicode?

IBM® Globalization

Go to the online ICU demos to see how a Unicode-based server application can handle text in many languages and many encodings.

Traditional Character Sets and Unicode

Representing text-format data in computers is a matter of defining a set of characters and assigning each of them a number and a bit representation. Underlying this basic idea are three related concepts:

A character set or repertoire is an unordered collection of characters that can be represented by numeric values.

A coded character set maps characters from a character set or repertoire to numeric values.

A character encoding scheme defines the representation of numeric values from one or more coded character sets in bits and bytes.

For simple encodings such as ASCII, the last two concepts are basically the same: ASCII assigns 128 characters and control codes to consecutive numbers from 0 to 127. These characters and control codes are encoded as simple, unsigned, binary integers. Therefore, ASCII is both a coded character set and a character encoding scheme.

ASCII only encodes 128 characters, 33 of which are control codes rather than graphic, displayable characters. It was designed to represent English-language text for an American user base, and is therefore insufficient for representing text in almost any language other than American English. In fact, most traditional encodings were limited to one or few languages and scripts.

ASCII offered a natural way to extend it: Designed in the 1960's to work in systems with 7-bit bytes while most computers and Internet protocols since the 1970's use 8-bit bytes, the extra bit allowed another 128 byte values to represent more characters. Various encodings were developed that supported different languages. Some of these were based on ASCII, others were not.

Languages such as Japanese need to encode considerably more than 256 characters. Various encoding schemes enable large character sets with thousands or tens of thousands of characters to be represented. Most of those encodings are still byte-based, which means that many characters require two or more bytes of storage space. A process must be developed to interpret some byte values.

Various character sets and encoding schemes have been developed independently, cover only one or few languages each, and are incompatible. This makes it very difficult for a single system to handle text in more than one language at a time, and especially difficult to do so in a way that is interoperable across different systems.

Generally, the minimum requirement for the interoperable exchange of text data is that the encoding (character set & encoding scheme) must be properly specified in the document and in the protocol. For example, email/SMTP and HTML/HTTP provide the means to specify the "charset", as it is called in Internet standards. However, very often the encoding is not specified, specified incorrectly, or the sender and receiver disagree on its implementation.

The ISO 2022 encoding scheme was created to store text in many different languages. It allows other encodings to be embedded by first announcing them and then switching between them. Full support for all features and possible encodings with ISO 2022 requires complicated processing and the need to support many encodings. For East Asian languages, subsets were developed that cover only one language or a few at a time, but they are much more manageable. ISO 2022 is not well-suited for use in internal processing. It is designed for data exchange.

Glyphs versus Characters

Programmers often need to distinguish between characters and glyphs. A character is the smallest semantic unit in a writing system. It is an abstract concept such as the letter A or the exclamation point. A glyph is the visual presentation of one or more characters, and is often dependent on adjacent characters.

There is not always a one-to-one mapping between characters and glyphs. In many languages (Arabic is a prime example), the way a character looks depends heavily on the surrounding characters. Standard printed Arabic has as many as four different printed representations (glyphs) for every letter of the alphabet. In many languages, two or more letters may combine together into a single glyph (called a ligature), or a single character might be displayed with more than one glyph.

Despite the different visual variants of a particular letter, it still retains its identity. For example, the Arabic letter heh has four different visual representations in common use. Whichever one is used, it still keeps its identity as the letter heh. It is this identity that Unicode encodes, not the visual representation. This also cuts down on the number of independent character values required.

Overview of Unicode

Unicode was developed as a single-coded character set that contains support for all languages in the world. The first version of Unicode used 16-bit numbers, which allowed for encoding 65,536 characters without complicated multibyte schemes. With the inclusion of more characters, and following implementation needs of many different platforms, Unicode was extended to allow more than one million characters. Several other encoding schemes were added. This introduced more complexity into the Unicode standard, but far less than managing a large number of different encodings.

Starting with Unicode 2.0 (published in 1996), the Unicode standard began assigning numbers from 0 to 10ffff16, which requires 21 bits but does not use them completely. This gives more than enough room for all written languages in the world. The original repertoire covered all major languages commonly used in computing. Unicode continues to grow, and it includes more scripts.

The design of Unicode differs in several ways from traditional character sets and encoding schemes:

Its repertoire enables users to include text efficiently in almost all languages within a single document.

It can be encoded in a byte-based way with one or more bytes per character, but the default encoding scheme uses 16-bit units that allow much simpler processing for all common characters.

Many characters, such as letters with accents and umlauts, can be combined from the base character and accent or umlaut modifiers. This combining reduces the number of different characters that need to be encoded separately. "Precomposed" variants for characters that existed in common character sets at the time were included for compatibility.

Characters and their usage are well-defined and described. While traditional character sets typically only provide the name or a picture of a character and its number and byte encoding, Unicode has a comprehensive database of properties available for download. It also defines a number of processes and algorithms for dealing with many aspects of text processing to make it more interoperable.

The early inclusion of all characters of commonly used character sets makes Unicode a useful "pivot" point for converting between traditional character sets, and makes it feasible to process non-Unicode text by first converting into Unicode, process the text, and convert it back to the original encoding without loss of data.

Note	The first 128 Unicode code point values are assigned to the same characters as in US-ASCII. For example, the same number is assigned to the same character. The same is true for the first 256 code point values of Unicode compared to ISO 8859-1 (Latin-1) which itself is a direct superset of US-ASCII. This makes it easy to adapt many applications to Unicode because the numbers for many syntactically important characters are the same.
Character Encoding Forms and Schemes for Unicode

Unicode assigns characters a number from 0 to 10FFFF16, giving enough elbow room to allow for unambiguous encoding of every character in common use. Such a character number is called a "code point".

Note	Unicode code points are just non-negative integer numbers in a certain range. They do not have an implicit binary representation or a width of 21 or 32 bits. Binary representation and unit widths are defined for encoding forms.
For internal processing, the standard defines three encoding forms, and for file storage and protocols, some of these encoding forms have encoding schemes that differ in their byte ordering. The difference between an encoding form and an encoding scheme is that an encoding form maps the character set codes to values that fit into internal data types (like a short in C), while an encoding scheme maps to bits and bytes. For traditional encodings, they are the same since the encoding forms already map to bytes

. The different Unicode encoding forms are optimized for a variety of different uses:

UTF-16, the default encoding form, maps a character code point to either one or two 16-bit integers.

UTF-8 is a byte-based encoding that offers backwards compatibility with ASCII-based, byte-oriented APIs and protocols. A character is stored with 1, 2, 3, or 4 bytes.

UTF-32 is the simplest but most memory-intensive encoding form: It uses one 32-bit integer per Unicode character.

SCSU is an encoding scheme that provides a simple compression of Unicode text. It is designed only for input and output, not for internal use.

ICU uses UTF-16 internally. ICU 2.0 fully supports supplementary characters (with code points 1000016..10FFFF16. Older versions of ICU provided only partial support for supplementary characters.

For input/output, character encoding schemes define a byte serialization of text. UTF-8 is itself both an encoding form and an encoding scheme because it is byte-based. For each of UTF-16 and UTF-32, there are two variants defined: one that serializes the code units in big-endian byte order (most significant byte first), and one that serializes the code units in little-endian byte order (least significant byte first). The corresponding encoding schemes are called UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE.

Note	The names "UTF-16" and "UTF-32" are ambiguous. Depending on context, they refer either to character encoding forms where 16/32-bit words are processed and are naturally stored in the platform endianness, or they refer to the IANA-registered charset names, i.e., to character encoding schemes or byte serializations. In addition to simple byte serialization, the charsets with these names also use optional Byte Order Marks (see Serialized Formats (§) below).
Overview of UTF-16

The default encoding form of the Unicode Standard uses 16-bit code units. Code point values for the most common characters are in the range of 0 to FFFF16 and are encoded with just one 16-bit unit of the same value. Code points from 1000016 to 10FFFF16 are encoded with two code units that are often called "surrogates", and they are called a "surrogate pair" when, together, they correctly encode one Unicode character. The first surrogate in a pair must be in the range D80016 to DBFF16, and the second one must be in the range DC0016 to DFFF16. Every Unicode code point has only one possible UTF-16 encoding with either one code unit that is not a surrogate or with a correct pair of surrogates. The code point values D80016 to DFFF16 are set aside just for this mechanism and will never, by themselves, be assigned any characters.

Most commonly used characters have code points below FFFF16, but Unicode 3.1 assigns more than 40,000 supplementary characters that make use of surrogate pairs in UTF-16.

Note that comparing UTF-16 strings lexically based on their 16-bit code units does not result in the same order as comparing the code points. This is not usually an issue since only rarely-used characters are affected. Most processes do not rely on the same results in such comparisons. Where necessary, a simple modification to a string comparison can be performed that still allows efficient code unit-based comparisons and makes them compatible with code point comparisons. ICU has C and C++ API functions for this.

Overview of UTF-8

To meet the requirements of byte-oriented, ASCII-based systems, the Unicode Standard defines UTF-8. UTF-8 is a variable-length, byte-based encoding that preserves ASCII transparency.

UTF-8 maintains transparency for all of the ASCII code values (0..127). These values do not appear in any byte of a transformed result except as the direct representation of the ASCII values. Thus, ASCII text is also UTF-8 text.

Characteristics of UTF-8 include:

Unicode code points 0 to 7F16 are each encoded with a single byte of the same value. Therefore, ASCII characters take up 50% less space with UTF-8 encoding than with UTF-16.

All other code points are encoded with multibyte sequences, with the first byte (lead byte) indicating the number of bytes that follow (trail bytes). This results in very efficient parsing. The lead bytes are in the range c016 to fd16, the trail bytes are in the range 8016 to bf16. The byte values fe16 and FF16 are never used.

UTF-8 is relatively compact and resource conservative in its use of the bytes required for encoding text in European scripts, but uses 50% more space than UTF-16 for East Asian text. Code points up to 7FF16 take up two bytes, code points up to FFFF16 take up three (50% more memory than UTF-16), and all others four.

Binary comparisons of UTF-8 strings based on their bytes result in the same order as comparing code point values.

Overview of UTF-32

The UTF-32 encoding form always uses one single 32-bit integer per Unicode code point. This results in a very simple encoding.

The drawback is its memory consumption: Since code point values use only 21 bits, one-third of the memory is always unused, and since most commonly used characters have code point values of up to FFFF16, they take up only one 16-bit unit in UTF-16 (50% less) and up to three bytes in UTF-8 (25% less).

UTF-32 is mainly used in APIs that are defined with the same data type for both code points and code units. Modern versions of the C standard library that support Unicode use a 32-bit wchar_t with UTF-32 semantics.

Overview of SCSU

SCSU (Standard Compression Scheme for Unicode) is designed to reduce the size of Unicode text for both input and output. It is a simple compression that transforms the text into a byte stream. It typically uses one byte per character in small scripts, and two bytes per character in large, East Asian scripts.

It is usually shorter than any of the UTFs. However, SCSU is stateful, which makes it unsuitable for internal processing. It also uses all possible byte values, which might require additional processing for protocols such as SMTP (email).

See also http://www.unicode.org/unicode/reports/tr6/ .

Other Unicode Encodings

Other Unicode encodings have been developed over time for various purposes. Most of them are implemented in ICU, see source/data/mappings/convrtrs.txt

BOCU-1: Binary-Ordered Compression of Unicode
An encoding of Unicode that is about as compact as SCSU but has a much smaller amount of state. Unlike SCSU, it preserves code point order and can be used in 8bit emails without a transfer encoding. BOCU-1 does not preserve ASCII characters in ASCII-readable form. See Unicode Technical Note #6 .

UTF-7: Designed for 7bit emails; simple and not very compact. Since email systems have been 8-bit safe for several years, UTF-7 is not necessary any more and not recommended. Most ASCII characters are readable, others are base64-encoded. See RFC 2152 .

IMAP-mailbox-name: A variant of UTF-7 that is suitable for expressing Unicode strings as ASCII characters for Unix filenames.
The name "IMAP-mailbox-name" is specific to ICU!
See RFC 2060 INTERNET MESSAGE ACCESS PROTOCOL - VERSION 4rev1 section 5.1.3. Mailbox International Naming Convention.

UTF-EBCDIC: An EBCDIC-friendly encoding that is similar to UTF-8. See Unicode Technical Report #16 . As of ICU 2.6, UTF-EBCDIC is not implemented in ICU.
ICU Services
Contents
1 Overview of the ICU Services
1.1 Strings, Properties and CharacterIterator
1.2 Conversion Basics
1.3 Locale and Resources
1.4 Locales and Services
1.5 Transliteration
1.6 Date and Time Classes
1.7 Format and Parse
1.7.1 General Formatting
1.7.2 Formatting Numbers
1.7.3 Formatting Dates and Times
1.7.4 Formatting Messages
1.8 Searching and Sorting
1.9 Text Analysis
1.10 Text Layout
2 Locale-Dependent Operations
3 Locale-Independent Operations
Overview of the ICU Services

ICU enables you to write language-independent C and C++ code that is used on separate, localized resources to get language-specific results. ICU supports many features, including language-sensitive text, dates, time, numbers, currency, message sorting, and searching. ICU provides language-specific results for a broad range of languages.

Strings, Properties and CharacterIterator

ICU provides basic Unicode support for the following:

Unicode string 
ICU includes type definitions for UTF-16 strings and code points. It also contains many C u_string functions and the C++ UnicodeString class with many additional string functions.

Unicode properties 
ICU includes the C definitions and functions found in uchar.h as well as some macros found in utf.h. It also includes the C++ Unicode class.

Unicode string iteration 
In C, ICU uses the macros in utf.h for the iteration of strings. In C++, ICU uses the characterIterator and its subclasses.

Conversion Basics

A converter is used to transform text from one encoding type to another. In the case of Unicode, ICU transforms text from one encoding codepage to Unicode and back. An encoding is a mapping from a given character set definition to the actual bits used to represent the data.

Locale and Resources

The ICU package contains the locale and resource bundles as well as the classes that implement them. Also, the ICU package contains the locale data (plain text resource bundles) and provides APIs to access and make use of that data in various services. Users need to understand these terms and the relationship between them.

A locale identifies a group of users who have similar cultural and linguistic expectations for how their computers interact with them and process data. This is an abstract concept that is typically expressed by one of the following:  

A locale ID specifies a language and region enabling the software to support culturally and linguistically appropriate information for each user. A locale object represents a specific geographical, political, or cultural region. As a programmatic expression of locale IDs, ICU provides the C++ locale class. In C, Application Programming Interfaces (APIs) use simple C strings for locale IDs.

ICU stores locale-specific data in resource bundles, which provide a general mechanism to access strings and other objects for ICU services to perform according to locale conventions. ICU contains data for its services to support many locales. Resource bundles contain the locale data of applications that use ICU. In C++, the ResourceBundle implements the locale data. In C, this feature is provided by the ures_ interface.

In addition to storing system-level data in ICU's resource bundles, applications typically also need to use resource bundles of their own to store locale-dependent application data. ICU provides the generic resource bundle APIs to access these bundles and also provides the tools to build them.

Note	Display strings, which are displayed to a user of a program, are bundled in a separate file instead of being embedded in the lines of the program.
Locales and Services

The interaction between locales and services is fundamental to ICU. Please refer to the Locales and Services (§) section of the Locale chapter.

Transliteration

Transliteration was originally designed to convert characters from one script to another (for example, from Greek to Latin, or Japanese Katakana to Latin). Now, transliteration is a more flexible mechanism that has pre-built transformations for case conversions, normalization conversions, the removal of given characters, and also for a variety of language and script transliterations. Transliterations can be chained together to perform a series of operations and each step of the process can use a UnicodeSet to restrict the characters that are affected. There are two basic types of transliterators:  

Most natural language transliterators (such as Greek-Latin) are written a rule-based transliterators. Transliterators can be written as text files using a simple language that is similar to regular expression syntax.

Date and Time Classes

Date and time routines manage independent date and time functions in milliseconds since January 1, 1970 (0:00:00.000 UTC). Points in time before then are represented as negative numbers.

ICU provides the following classes to support calendars and time zones:

Calendar (§)
The abstract superclass for extracting calendar-related attributes from a Date value. (§)

Gregorian Calendar (§)
A concrete class for representing a Gregorian calendar.

TimeZone (§)
An abstract superclass for representing a time zone.

SimpleTimeZone (§)
A concrete class for representing a time zone for use with a Gregorian calendar.

Note	C classes provide the same functionality as the C++ classes with the exception of subclassing.
Format and Parse

Formatters translate between non-text data values and textual representations of those values. The result is a string of text that represents the internal value. A formatter can parse a string and convert a textual representation of some value (if it finds one it understands) back into its internal representation. For example, when the formatter reads the characters 1, 0, and 3 followed by something other than a digit, it produces the value 103 in its internal binary representation.

A formatter takes a value and produces a user-readable string that represents that value or takes a string and parses it to produce a value.

ICU provides the following areas and classes for general formatting, formatting numbers, formatting dates and times, and formatting messages:

General Formatting

Format 
Format is the abstract superclass of all format classes. It provides the basic methods for formatting and parsing numbers, dates, strings, and other objects.

FieldPosition (§) 
FieldPosition is a concrete class for holding the field constant and the beginning and ending indices for the number and date fields.

ParsePosition (§) 
ParsePosition is a concrete class for holding the parse position in a string during parsing.

Formattable (§) 
Objects that must be formatted can be passed to the Format class or its subclasses for formatting. The class encapsulates a polymorphic piece of data to be formatted and uses the MessageFormat class. Some formatting operations use the Formattable class to produce a single "type" that encompasses all formattable values such as a number, date, string, and so on.

Formatting Numbers

NumberFormat (§) 
NumberFormat provides the basic fields and methods to format number objects and number primitives into localized strings and parse localized strings to number objects.

DecimalFormat (§)
DecimalFormat provides the methods used to format number objects and number primitives into localized strings and parse localized strings into number objects in base 10.

DecimalFormatSymbols (§)
DecimalFormatSymbols is a concrete class used by DecimalFormat to access localized number strings such as the grouping separators, the decimal separator, and the percent sign.

Formatting Dates and Times

DateFormat (§)
DateFormat provides the basic fields and methods for formatting date objects to localized strings and parsing date and time strings to date objects.

SimpleDateFormat (§)
SimpleDateFormat is a concrete class used to format date objects to localized strings and to parse date and time strings to date objects using a GregorianCalendar.

DateFormatSymbols (§)
DateFormatSymbols is a concrete class used to access localized date and time formatting strings, such as names of the months, days of the week, and the time zone.

Formatting Messages

MessageFormat (§)
MessageFormat is a concrete class used to produce a language-specific user message that contains numbers, currency, percentages, date, time, and string variables.

ChoiceFormat (§)
ChoiceFormat is a concrete class used to map strings to ranges of numbers and to handle plural words and name series in user messages.

Note	C classes provide the same functionality as the C++ classes with the exception of subclassing.
Searching and Sorting

Sorting and searching non-English text presents a number of challenges that many English speakers are unaware of. The primary source of difficulty is accents, which have very different meanings in different languages, and sometimes even within the same language:

Many accented letters, such as the é in café, are treated as minor variants on the letter that is accented.

Sometimes the accented form of a letter is treated as a distinct letter for the purposes of comparison. For example, Å in Danish is treated as a separate letter that sorts just after Z.

In some cases, an accented letter is treated as if it were two letters. In traditional German, for example, ä is compared as if it were ae.

Searching and sorting is done through collation using the Collator class and its sub-classes RuleBasedCollator and CollationElementIterator as well as the CollationKey object. Collation determines the proper sort sequence for two or more natural language strings. It also can determine if two strings are equivalent for the purpose of searching.

The Collator class and its sub-class RuleBasedCollator perform locale-sensitive string comparisons to create sorting and searching routines for natural language text. Collator and RuleBasedCollator can distinguish between characters associated with base characters (such as 'a' and 'b'), accent marks (such as 'ò', 'ó'), and uppercase or lowercase properties (such as 'a' and 'A').

ICU provides the following collation classes for sorting and searching natural language text according to locale-specific rules:

Collator 
Collator is the abstract base class of all classes that compare strings.

CollationElementIterator 
CollationElementIterator is a concrete iterator class that provides an iterator for stepping through each character of a locale-specific string according to the rules of a specific collator object.

RuleBasedCollator 
RuleBasedCollator is the only built-in implementation of the collator. It provides a sophisticated mechanism for comparing strings in a language-specific manner, and an interface that allows the user to specifically customize the sorting order.

CollationKey 
CollationKey is an object that enables the fast sorting of strings by representing a string as a sort key under the rules of a specific collator object.

Note	C classes provide the same functionality as the C++ classes with the exception of subclassing.
Text Analysis

The BreakIterator services can be used for formatting and handling text; locating the beginning and ending points of a word; counting words, sentences, and paragraphs; and listing unique words. Specifically, text operations can be done to locate the following linguistic boundaries:

Display text on the screen and locate places in the text where the BreakIterator can perform word-wrapping to fit the text within the margins

Locate the beginning and end of a word that the user has selected

Count graphemes (or characters), words, sentences, or paragraphs

Determine how far to move in the text store when the user hits an arrow key to move forward or backward one grapheme

Make a list of all the unique words in a document

Figure out whether or not a range of text contains only whole words

Capitalize the first letter of each word

Extract a particular unit from the text such as "find me the third grapheme in this document"

The BreakIterator services were designed and developed around an "iterator" or "cursor" style of interface. The object points to a particular place in the text. You can move the pointer forward or backward to search the text for boundaries.

The BreakIterator class makes it possible to iterate over user characters. A BreakIterator can find the location of a character, word, sentence or potential line-break boundary. This makes it possible for a software program to properly select characters for text operations such as highlighting a character, cutting a word, moving to the next sentence, or wrapping words at a line ending. BreakIterator performs these operations in a locale-sensitive manner, meaning that it recognizes text boundaries according to the particular locale ID.

ICU provides the following classes for iterating over locale-specific text:

BreakIterator 
The abstract base class that defines the operations for finding and getting the positions of logical breaks in a string of text: characters, words, sentences, and potential line breaks.

CharacterIterator 
The abstract base class for forward and backward iteration over a string of Unicode characters.

StringCharacterIterator 
A concrete class for forward and backward iteration over a string of Unicode characters. StringCharacterIterator inherits from CharacterIterator.

Text Layout

Some scripts require rendering behavior that is more complicated than the Latin script. These scripts are called as "complex scripts" and while their text is called "complex text." Examples of complex scripts are the Indic scripts (Devanagari, Tamil, Telugu, and Gujarati), Thai scripts, and Arabic scripts.

Complex text has the following main characteristics:  

In most cases, the contextual and ligature forms of characters have not been assigned Unicode codepoints and thus cannot be displayed directly using codepoints.

The ICU LayoutEngine provides a uniform interface for preparing complex text for display. The LayoutEngine code is independent of the font and rendering architecture of the underlying platform. All access to the LayoutEngine code is through an abstract base class. A concrete instance of this base class must be implemented for each platform.

The ICU LayoutEngine prepares complex text using the following procedures:  

Locale-Dependent Operations

Many of the ICU classes are locale-sensitive, meaning that you have to create a different one for each locale.

C API	C++ Class	Description
ubrk_	BreakIterator	The BreakIterator class implements methods to find the location of boundaries in the text.
ucal_	Calendar	The Calendar class is an abstract base class that converts between a UDate object and a set of integer fields such as YEAR, MONTH, DAY, HOUR, and so on.
umsg.h	ChoiceFormat	A ChoiceFormat class enables you to attach a format to a range of numbers.
ucol_	CollationElementIterator	The CollationElementIterator class is used as an iterator to walk through each character of an international string.
ucol_	CollationKey	The Collator class generates the Collation keys.
ucol_	Collator	The Collator class performs locale-sensitive string comparison.
udat_	DateFormat	DateFormat is an abstract class for a family of classes. DateFormat converts dates and times from their internal representations to a textual form that is language-independent, and then back to their internal representations.
udat_	DateFormatSymbols	DateFormatSymbols is a public class that encapsulates localized date and time formatting data. This information includes time zone information.
unum_	DecimalFormatSymbols	This class represents the set of symbols needed by DecimalFormat to format numbers.
umsg.h	Format	The Format class is the base class for all formats.
ucal_	GregorianCalendar	GregorianCalendar is a concrete class that provides the standard calendar used in many locations.
uloc_	Locale	A Locale object represents a specific geographical, political, or cultural region.
umsg.h	MessageFormat	MessageFormat provides a means to produce concatenated messages in language-neutral way.
unum_	NumberFormat	NumberFormat is an abstract base class for all number formats.
ures_	ResourceBundle	ResourceBundle provides a means to access a collection of locale-specific information.
ucol_	RuleBasedCollator	The RuleBasedCollator provides the implementation of the Collator class using data-driven tables.
udat_	SimpleDateFormat	SimpleDateFormat is a concrete class used to format and parse dates in a language-independent way.
ucal_	SimpleTimeZone	SimpleTimeZone is a concrete subclass of TimeZone that represents a time zone for use with a Gregorian calendar.
usearch_	StringSearch	StringSearch provides a way to search text in a locale sensitive manner.
ucal_	TimeZone	TimeZone represents a time zone offset, and also determines daylight savings time settings.
Locale-Independent Operations

The following ICU services can be used in all locales as they provide locale-independent services and users do not need to specify a locale ID:

C API	C++ Class	Description
ubidi_	 	UBiDi is used for implementing the Unicode BiDi algorithm.
utf.h	CharacterIterator	CharacterIterator is an abstract class that defines an API for iteration on text objects. It is an interface for forward and backward iteration and for the random access of a text object. Also, it provides backward compatibility to the Java and older ICU CharacterIterator classes.
n/a	Formattable	Formattable is a thin wrapper class that converts between the primitive numeric types (double, long, and so on) and the UDate and UnicodeString classes. Formattable objects can be passed to the Format class or its subclasses for formatting.
unorm_	Normalizer	Normalizer transforms Unicode text into an equivalent composed or decomposed form to allow for easier sorting and searching of text.
n/a	ParsePosition	ParsePosition is a simple class used by the Format class and its subclasses to keep track of the current position during parsing.
uidna_	 	An implementation of the IDNA protocol as defined in RFC 3490.
utf.h	StringCharacterIterator	A concrete subclass of CharacterIterator that iterates over the characters (code units or code points) in a UnicodeString.
utf.h	UCharCharacterIterator	A concrete subclass of CharacterIterator that iterates over the characters (code units or code points) in a UChar array.
uchar.h	 	The Unicode character properties API allows you to query the properties associated with individual Unicode character values.
uregex_	RegexMatcher	RegexMatcher is a regular expressions implementation. This allows you to perform string matching based upon a pattern.
utrans_	Transliterator	Transliterator is an abstract class that transliterates text from one format to another. The most common type of transliterator is a script, or an alphabet.
uset_	UnicodeSet	Objects of the UnicodeSet class represent character classes used in regular expressions. These classes specify a subset of the set of all Unicode characters. This is a mutable set of Unicode characters.
ustring.h	UnicodeString	UnicodeString is a string class that stores Unicode characters directly. This class is a concrete implementation of the abstract class Replaceable.
ushape.h	 	Provides operations to transform (shape) between Arabic characters and their presentation forms.
ucnv_	 	The Unicode conversion API allows you to convert data written in one codepage/encoding to and from UTF-16.
